---
import { Image } from "astro:assets";
import missile from "@assets/img/missile.png";

// Configuration matching Java applet
const numberOfMissiles = 10; // Adjust based on difficulty
const initialSpeed = 8; // Slowed down for web version
---

<div
  id="missile-container"
  class="absolute inset-0 overflow-hidden pointer-events-none"
>
  {
    Array.from({ length: numberOfMissiles }).map((_, i) => (
      <Image
        src={missile}
        alt=""
        class="missile absolute will-change-transform"
        data-missile-index={i}
        loading="eager"
      />
    ))
  }
</div>

<script define:vars={{ numberOfMissiles, initialSpeed }}>
  // Missile state arrays - matching Java implementation
  const xPos = new Array(numberOfMissiles);
  const yPos = new Array(numberOfMissiles);
  const onScreen = new Array(numberOfMissiles); // Visibility state
  let speed = initialSpeed; // Global speed (static in Java)

  // Missile image dimensions (centered at -20, -20 in Java)
  const MISSILE_SIZE = 40;
  const MISSILE_OFFSET = MISSILE_SIZE / 2;

  // Cache missile elements to avoid repeated DOM queries
  let missileElements = [];

  // Accessibility: check for reduced motion preference
  const reducedMotionQuery = window.matchMedia(
    "(prefers-reduced-motion: reduce)"
  );
  const prefersReducedMotion = reducedMotionQuery.matches;
  let animationId = null;

  // Dynamic screen dimensions
  let screenWidth = window.innerWidth;
  let screenHeight = window.innerHeight;

  // Initialize missile positions (matching Java Missile constructor & reset())
  function initMissiles() {
    screenWidth = window.innerWidth;
    screenHeight = window.innerHeight;

    for (let i = 0; i < numberOfMissiles; i++) {
      xPos[i] = Math.random() * screenWidth; // Full width of browser
      yPos[i] = Math.random() * -1600; // -1600 to 0 (off-screen above)
      onScreen[i] = true;
    }
  }

  // Reset individual missile (matching Java reset() method)
  function resetMissile(i) {
    xPos[i] = Math.random() * screenWidth;
    yPos[i] = Math.random() * -1600;
    onScreen[i] = true;
  }

  // Change speed (matching Java changeSpeed() static method)
  function changeSpeed() {
    speed = speed + 10;
    if (speed > 30) {
      speed = 30;
    }
  }

  // Calculate distance to a point (matching Java distanceTo() method)
  function distanceTo(missileIndex, someX, someY) {
    const dX = someX - xPos[missileIndex];
    const dY = someY - yPos[missileIndex];
    return Math.sqrt(dX * dX + dY * dY);
  }

  // Explode missile (matching Java explode() method)
  function explode(i) {
    onScreen[i] = false;
  }

  // Callback for when missile reaches bottom (for scoring)
  let onMissileReachedBottom = null;

  // Update missile positions (matching Java flight() method)
  function updateMissiles() {
    for (let i = 0; i < numberOfMissiles; i++) {
      if (onScreen[i]) {
        // Move missile down by speed (flight() method)
        yPos[i] = yPos[i] + speed;

        // Check if missile reached bottom (matching Java's y >= 800 check)
        if (yPos[i] >= screenHeight) {
          // Notify game logic (for scoring: playerScore += 10)
          if (onMissileReachedBottom) {
            onMissileReachedBottom(i);
          }
          resetMissile(i);
        }
      }
    }
  }

  // Render missiles to DOM (matching Java paint() method)
  function renderMissiles() {
    missileElements.forEach((missile, i) => {
      if (onScreen[i]) {
        // Draw at x-20, y-20 to center the missile (matching Java paint)
        missile.style.transform = `translate(${xPos[i] - MISSILE_OFFSET}px, ${yPos[i] - MISSILE_OFFSET}px)`;
        missile.style.visibility = "visible";
      } else {
        missile.style.visibility = "hidden";
      }
    });
  }

  // Animation loop
  function animate() {
    if (!prefersReducedMotion) {
      updateMissiles();
      renderMissiles();
    }
    animationId = requestAnimationFrame(animate);
  }

  // Event handlers
  const handleResize = () => {
    screenWidth = window.innerWidth;
    screenHeight = window.innerHeight;
  };

  const handleMotionPreferenceChange = (e) => {
    if (e.matches && animationId) {
      cancelAnimationFrame(animationId);
      animationId = null;
    } else if (!e.matches && !animationId) {
      animate();
    }
  };

  // Cleanup function to prevent memory leaks
  const cleanup = () => {
    if (animationId) {
      cancelAnimationFrame(animationId);
      animationId = null;
    }
    window.removeEventListener("resize", handleResize);
    reducedMotionQuery.removeEventListener(
      "change",
      handleMotionPreferenceChange
    );
  };

  // Handle window resize
  window.addEventListener("resize", handleResize);

  // Listen for changes to reduced motion preference
  reducedMotionQuery.addEventListener("change", handleMotionPreferenceChange);

  // Cleanup on page unload
  window.addEventListener("pagehide", cleanup);
  window.addEventListener("beforeunload", cleanup);

  // Start animation on page load
  initMissiles();
  // Cache missile elements once
  missileElements = Array.from(document.querySelectorAll(".missile"));
  renderMissiles(); // Initial render
  if (!prefersReducedMotion) {
    animate();
  }

  // Export functions for external use (e.g., collision detection, game logic)
  window.missileAPI = {
    distanceTo,
    explode,
    changeSpeed,
    resetMissile,
    getMissilePosition: (i) => ({
      x: xPos[i],
      y: yPos[i],
      onScreen: onScreen[i],
    }),
    getMissileCount: () => numberOfMissiles,
    // Set callback for when missile reaches bottom (for scoring)
    setOnMissileReachedBottom: (callback) => {
      onMissileReachedBottom = callback;
    },
  };
</script>
