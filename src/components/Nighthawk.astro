---
import { Image } from "astro:assets";
import nighthawk from "@assets/img/nighthawk.png";
---

<Image
  id="nighthawk"
  class="absolute z-20 bottom-0 left-1/2 w-17 h-116.5"
  src={nighthawk}
  alt="F-117 Nighthawk"
  widths={[68, 136]}
  sizes="68px"
  loading="eager"
/>

<script>
  const nighthawk = document.getElementById("nighthawk") as HTMLElement;

  if (nighthawk) {
    let xPosition = 0;
    let xVelocity = 0;
    let tilt = 0;
    let minBoundary = 0;
    let maxBoundary = 0;

    const acceleration = 0.5;
    const maxSpeed = 5;
    const friction = 0.92;
    const tiltAmount = 15; // degrees
    const collisionDistance = 40; // pixels - collision threshold

    const keys = {
      a: false,
      d: false,
    };

    function calculateBoundaries() {
      const viewportWidth = window.innerWidth;
      const nighthawkWidth = nighthawk.offsetWidth;

      // Calculate how far the plane can move from center
      // Account for the plane being centered at 50% initially
      minBoundary = -(viewportWidth / 2 - nighthawkWidth / 2);
      maxBoundary = viewportWidth / 2 - nighthawkWidth / 2;
    }

    function updatePhysics() {
      // Apply acceleration based on key presses
      if (keys.a) {
        xVelocity -= acceleration;
      }
      if (keys.d) {
        xVelocity += acceleration;
      }

      // Apply friction when no keys are pressed
      if (!keys.a && !keys.d) {
        xVelocity *= friction;
      }

      // Clamp velocity to max speed
      xVelocity = Math.max(-maxSpeed, Math.min(maxSpeed, xVelocity));

      // Update position
      xPosition += xVelocity;

      // Apply boundaries and stop velocity if hitting the edge
      if (xPosition < minBoundary) {
        xPosition = minBoundary;
        xVelocity = 0;
      } else if (xPosition > maxBoundary) {
        xPosition = maxBoundary;
        xVelocity = 0;
      }

      // Calculate tilt based on velocity
      tilt = (xVelocity / maxSpeed) * tiltAmount;

      // Stop completely if velocity is very small
      if (Math.abs(xVelocity) < 0.01) {
        xVelocity = 0;
      }

      updatePosition();
    }

    function updatePosition() {
      nighthawk.style.transform = `translateX(calc(-50% + ${xPosition}px)) rotateZ(${tilt}deg)`;
    }

    let animationFrameId: number | null = null;
    let isAnimating = false;

    function animate() {
      // Stop if element has been removed from DOM
      if (!document.contains(nighthawk)) {
        cleanup();
        return;
      }

      updatePhysics();

      // Check for collisions with missiles if game is active
      if (window.gameAPI?.gameStarted && window.gameAPI?.missiles) {
        const nighthawkRect = nighthawk.getBoundingClientRect();
        const nighthawkCenterX = nighthawkRect.left + nighthawkRect.width / 2;
        const nighthawkCenterY = nighthawkRect.top + nighthawkRect.height / 2;

        const missileCount = window.gameAPI.missiles.getMissileCount();
        for (let i = 0; i < missileCount; i++) {
          const missilePos = window.gameAPI.missiles.getMissilePosition(i);
          if (missilePos && missilePos.onScreen) {
            // Calculate distance between centers (missiles are 40x40, so center is at x+20, y+20)
            const dX = nighthawkCenterX - missilePos.x;
            const dY = nighthawkCenterY - missilePos.y;
            const distance = Math.sqrt(dX * dX + dY * dY);

            if (distance < collisionDistance) {
              // Collision detected!
              window.gameAPI.missiles.explode(i);
              // Trigger game over
              window.dispatchEvent(new CustomEvent("gameover"));
              // Stop animation but keep event listeners
              stopAnimation();
              return;
            }
          }
        }
      }

      // Continue animation if there's movement or keys are pressed
      if (xVelocity !== 0 || keys.a || keys.d) {
        animationFrameId = requestAnimationFrame(animate);
      } else {
        isAnimating = false;
        animationFrameId = null;
      }
    }

    function startAnimation() {
      if (!isAnimating) {
        isAnimating = true;
        animate();
      }
    }

    // Event handler functions
    const handleResize = () => {
      calculateBoundaries();
    };

    const handleKeyDown = (event: KeyboardEvent) => {
      // Don't allow movement until player can move
      if (!window.gameAPI?.playerCanMove) {
        return;
      }

      // Ignore if typing in an input field or using modifier keys
      const target = event.target as HTMLElement;
      if (
        target.tagName === "INPUT" ||
        target.tagName === "TEXTAREA" ||
        target.isContentEditable ||
        event.ctrlKey ||
        event.metaKey ||
        event.altKey ||
        event.shiftKey
      ) {
        return;
      }

      if (event.key === "a" || event.key === "A") {
        event.preventDefault();
        keys.a = true;
        startAnimation();
      } else if (event.key === "d" || event.key === "D") {
        event.preventDefault();
        keys.d = true;
        startAnimation();
      }
    };

    const handleKeyUp = (event: KeyboardEvent) => {
      // Always process key releases to maintain accurate key state
      // Ignore if typing in an input field or using modifier keys
      const target = event.target as HTMLElement;
      if (
        target.tagName === "INPUT" ||
        target.tagName === "TEXTAREA" ||
        target.isContentEditable ||
        event.ctrlKey ||
        event.metaKey ||
        event.altKey ||
        event.shiftKey
      ) {
        return;
      }

      if (event.key === "a" || event.key === "A") {
        keys.a = false;
      } else if (event.key === "d" || event.key === "D") {
        keys.d = false;
      }
    };

    // Stop animation without removing event listeners
    function stopAnimation() {
      if (animationFrameId !== null) {
        cancelAnimationFrame(animationFrameId);
        animationFrameId = null;
      }
      isAnimating = false;
    }

    // Reset function to restore initial state and restart animation
    function reset() {
      xPosition = 0;
      xVelocity = 0;
      tilt = 0;
      keys.a = false;
      keys.d = false;
      updatePosition();
      // Restart animation on reset
      startAnimation();
    }

    // Cleanup function to remove event listeners and cancel animation
    function cleanup() {
      stopAnimation();
      window.removeEventListener("resize", handleResize);
      document.removeEventListener("keydown", handleKeyDown);
      document.removeEventListener("keyup", handleKeyUp);
      // Clean up API
      if (window.gameAPI?.nighthawk) {
        delete window.gameAPI.nighthawk;
      }
    }

    // Initialize boundaries and position
    calculateBoundaries();
    updatePosition();

    // Add event listeners
    window.addEventListener("resize", handleResize);
    document.addEventListener("keydown", handleKeyDown);
    document.addEventListener("keyup", handleKeyUp);

    // Expose functions for game control
    if (!window.gameAPI) {
      window.gameAPI = {};
    }
    window.gameAPI.nighthawk = {
      reset,
      getNighthawkPosition: () => {
        const rect = nighthawk.getBoundingClientRect();
        return {
          x: rect.left + rect.width / 2,
          y: rect.top + rect.height / 2,
        };
      },
    };

    // Cleanup on page navigation (Astro view transitions)
    document.addEventListener("astro:before-preparation", cleanup);
    document.addEventListener("astro:page-load", cleanup);
  } else {
    console.error("Nighthawk element not found");
  }
</script>
